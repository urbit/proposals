## `~ponnys-podfer`
One thing we were thinking about doing is denormalizing the listeners into every build, not just root builds. This would allow us to decide, when we encounter a once-build of a live `%scry` schematic, not to enqueue a Clay subscription. We'd be able to do this because we'll have the information at hand about whether the build is live inside of `+make`. We can use existing data structures because `:builds-by-listener.state` will still map from a duct only to a root build. We'll change the usage of `:listeners.state` to include a key for each sub-build.

Curtis suggested that the whole idea of performing a once-build of a live dependency makes no sense. He has a point. He suggested modifying the data structures so that this is an impossible case. One option to achieve that would be to normalize live dependencies that are sub-builds of once builds, freezing them in time. We're not entirely sure how to implement that. ¯\_(ツ)_/¯

One redesign that would fix the liveness issue would be to remove the concept of time from the `%make`. Right now, `%make` takes an `(unit @da)`. If a pinned date is passed, that's the once build time. If `~` is passed, then it is a live build. 

Instead, have a new schematic type which pins a once-build time to its children. When a schematic resolves to a build, the time propagates downward to all child builds. Every build is a triple of `[date=@pa live=? =schematic]`. If the schematic had a pinned date, that date is used; otherwise the current time, as every build must have a date. We track liveness since we don't have the `(unit @da)` from the `%make`. This lets us track in every build whether it is live or not. We calculate liveness based on whether the requested schematic is under a `%pin` schematic. If it is not, and we had to wrap the requested schematic in a pin in order to resolve its time, then it is a live build.

For live builds we also need to store the unresolved schematic so whenever any of its live dependencies update, we can wrap the schematic in a `%pin` of the date of the dependency update each time we rebuild.

One question we're running into with this approach is whether there's a third kind of build other than live and once: an eternal/static/constant build. Live and once describe how the build relates to parts of the Urbit namespace that can vary. A static build, such as a `%$` (literal) just produces the passed-in value exactly. This does not fit into either live or once. There's an argument to be made that it's just a trivial live build, since it isn't pinned to a date. There are two cases: (a) in the case where you have a leaf eternal build, if you're in a once build, your once `%pin` will be above it, (b) when there is no `%pin` above the leaf eternal build, it still is a live build.

It's possible for a once build to contain pins at different dates. For example, an autocons of two `%scry` schematics pinned at different dates. In that case, we should consider the root build to have a formal date of the later of the two. More generally, the latest pin sets the formal date. (We won't be able to finish the build until we reach that date.)

Daily [work in progress](https://github.com/eglaysher/arvo/commit/b6ba2026b9fb9a3b1bbc5fad902fcefcea036afd).
